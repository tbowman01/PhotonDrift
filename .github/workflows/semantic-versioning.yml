name: Semantic Versioning & Automated Releases

on:
  push:
    branches: 
      - develop
      - main
    paths:
      - 'src/**'
      - 'Cargo.toml'
      - 'wasm/**'
      - '!**.md'
  workflow_dispatch:
    inputs:
      increment_type:
        description: 'Version increment type'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
      force_tag:
        description: 'Force create git tag'
        required: false
        default: false
        type: boolean
      branch_override:
        description: 'Override target branch (advanced)'
        required: false
        type: string

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  version-check:
    name: Version Check & Planning
    runs-on: ubuntu-latest
    outputs:
      should_version: ${{ steps.check.outputs.should_version }}
      current_version: ${{ steps.check.outputs.current_version }}
      branch_name: ${{ steps.check.outputs.branch_name }}
      increment_type: ${{ steps.check.outputs.increment_type }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Check if versioning should proceed
        id: check
        run: |
          BRANCH_NAME="${{ github.event.inputs.branch_override || github.ref_name }}"
          CURRENT_VERSION=$(grep '^version = ' Cargo.toml | head -1 | cut -d'"' -f2)
          INCREMENT_TYPE="${{ github.event.inputs.increment_type || 'patch' }}"
          
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "increment_type=$INCREMENT_TYPE" >> $GITHUB_OUTPUT
          
          # Determine if we should proceed with versioning
          if [[ "$BRANCH_NAME" == "develop" || "$BRANCH_NAME" == "main" ]]; then
            echo "should_version=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Versioning enabled for branch: $BRANCH_NAME"
          else
            echo "should_version=false" >> $GITHUB_OUTPUT
            echo "‚è≠Ô∏è Skipping versioning for branch: $BRANCH_NAME"
          fi
          
          echo "Current version: $CURRENT_VERSION"
          echo "Target branch: $BRANCH_NAME"
          echo "Increment type: $INCREMENT_TYPE"

  semantic-versioning:
    name: Generate Semantic Version
    runs-on: ubuntu-latest
    needs: version-check
    if: needs.version-check.outputs.should_version == 'true'
    outputs:
      new_version: ${{ steps.version.outputs.version }}
      version_tag: ${{ steps.version.outputs.tag }}
      is_prerelease: ${{ steps.version.outputs.is_prerelease }}
      version_type: ${{ steps.version.outputs.version_type }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Configure Git
        run: |
          git config --global user.name "PhotonDrift Automation"
          git config --global user.email "automation@photondrift.io"
      
      - name: Generate semantic version
        id: version
        run: |
          # Make script executable
          chmod +x scripts/semantic-version.sh
          
          # Run versioning script
          INCREMENT_TYPE="${{ needs.version-check.outputs.increment_type }}"
          FORCE_TAG="${{ github.event.inputs.force_tag || 'false' }}"
          
          if [[ "$FORCE_TAG" == "true" ]]; then
            ./scripts/semantic-version.sh "$INCREMENT_TYPE" --force-tag
          else
            ./scripts/semantic-version.sh "$INCREMENT_TYPE"
          fi
        env:
          GITHUB_ACTIONS: true
          GITHUB_OUTPUT: ${{ env.GITHUB_OUTPUT }}
          CI: true
      
      - name: Commit version update
        run: |
          # Check if there are changes to commit
          if git diff --quiet Cargo.toml; then
            echo "No changes to Cargo.toml - skipping commit"
            exit 0
          fi
          
          NEW_VERSION="${{ steps.version.outputs.version }}"
          BRANCH_NAME="${{ needs.version-check.outputs.branch_name }}"
          
          # Add changes
          git add Cargo.toml version-info.json
          
          # Create commit message
          COMMIT_MSG="chore: bump version to ${NEW_VERSION}

Branch: ${BRANCH_NAME}
Version type: ${{ steps.version.outputs.version_type }}
Automated semantic versioning

Generated by PhotonDrift CI/CD pipeline"
          
          # Commit changes
          git commit -m "$COMMIT_MSG"
          
          # Push changes
          git push origin HEAD
          
          echo "‚úÖ Version bump committed and pushed"
      
      - name: Upload version artifacts
        uses: actions/upload-artifact@v4
        with:
          name: version-info
          path: |
            version-info.json
            Cargo.toml
          retention-days: 30

  build-and-test:
    name: Build & Test (${{ matrix.target }})
    runs-on: ${{ matrix.os }}
    needs: [version-check, semantic-versioning]
    if: needs.version-check.outputs.should_version == 'true'
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            asset_name: adrscan-linux-amd64
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            asset_name: adrscan-windows-amd64.exe
          - os: macos-latest
            target: x86_64-apple-darwin
            asset_name: adrscan-macos-amd64
    
    steps:
      - name: Checkout updated repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0
      
      - name: Pull latest changes
        run: git pull origin ${{ github.ref_name }}
      
      - name: Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}
      
      - name: Setup Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          key: ${{ matrix.target }}
      
      - name: Run tests
        run: cargo test --target ${{ matrix.target }} --verbose
      
      - name: Build release binary
        run: |
          cargo build --release --target ${{ matrix.target }} --verbose
          
          # Copy binary to predictable location
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            cp target/${{ matrix.target }}/release/adrscan.exe ${{ matrix.asset_name }}
          else
            cp target/${{ matrix.target }}/release/adrscan ${{ matrix.asset_name }}
          fi
      
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.asset_name }}
          path: ${{ matrix.asset_name }}
          retention-days: 30

  wasm-build:
    name: Build WASM Module
    runs-on: ubuntu-latest
    needs: [version-check, semantic-versioning]
    if: needs.version-check.outputs.should_version == 'true'
    
    steps:
      - name: Checkout updated repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0
      
      - name: Pull latest changes
        run: git pull origin ${{ github.ref_name }}
      
      - name: Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-unknown-unknown
      
      - name: Install wasm-pack
        run: curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh
      
      - name: Build WASM module
        run: |
          # Build WASM with optimizations
          cargo build --target wasm32-unknown-unknown --features wasm --release --lib
          
          # Generate wasm-bindgen bindings if needed
          if command -v wasm-bindgen &> /dev/null; then
            wasm-bindgen target/wasm32-unknown-unknown/release/adrscan.wasm \
              --out-dir wasm --web --typescript
          fi
          
          # Verify WASM file size and functionality
          ls -la target/wasm32-unknown-unknown/release/adrscan.wasm
          wasm_size=$(stat -f%z target/wasm32-unknown-unknown/release/adrscan.wasm 2>/dev/null || stat -c%s target/wasm32-unknown-unknown/release/adrscan.wasm)
          echo "WASM size: $wasm_size bytes"
          
          if [[ $wasm_size -lt 1000 ]]; then
            echo "‚ùå WASM build failed - file too small ($wasm_size bytes)"
            exit 1
          else
            echo "‚úÖ WASM build successful - $wasm_size bytes"
          fi
      
      - name: Upload WASM artifacts
        uses: actions/upload-artifact@v4
        with:
          name: wasm-module
          path: |
            target/wasm32-unknown-unknown/release/adrscan.wasm
            wasm/
          retention-days: 30

  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [semantic-versioning, build-and-test, wasm-build]
    if: always() && needs.semantic-versioning.result == 'success'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts
      
      - name: Prepare release assets
        run: |
          mkdir -p release-assets
          
          # Copy binary artifacts
          find ./artifacts -name "adrscan-*" -type f -exec cp {} release-assets/ \;
          
          # Copy WASM artifacts
          if [[ -f "./artifacts/wasm-module/target/wasm32-unknown-unknown/release/adrscan.wasm" ]]; then
            cp "./artifacts/wasm-module/target/wasm32-unknown-unknown/release/adrscan.wasm" release-assets/adrscan.wasm
          fi
          
          # Copy version info
          if [[ -f "./artifacts/version-info/version-info.json" ]]; then
            cp "./artifacts/version-info/version-info.json" release-assets/
          fi
          
          echo "Release assets:"
          ls -la release-assets/
      
      - name: Generate release notes
        id: release_notes
        run: |
          VERSION="${{ needs.semantic-versioning.outputs.new_version }}"
          VERSION_TYPE="${{ needs.semantic-versioning.outputs.version_type }}"
          BRANCH_NAME="${{ github.ref_name }}"
          
          cat > release-notes.md << EOF
          # PhotonDrift $VERSION
          
          **Branch**: $BRANCH_NAME  
          **Type**: $VERSION_TYPE release  
          **Commit**: \`$(git rev-parse --short HEAD)\`  
          **Build Date**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          
          ## What's Included
          
          ### üöÄ Binary Releases
          - **Linux (x64)**: \`adrscan-linux-amd64\`
          - **Windows (x64)**: \`adrscan-windows-amd64.exe\`
          - **macOS (x64)**: \`adrscan-macos-amd64\`
          
          ### üåê WebAssembly
          - **WASM Module**: \`adrscan.wasm\` - Optimized for web integration
          
          ### üìã Metadata
          - **Version Info**: \`version-info.json\` - Complete build metadata
          
          ## Installation
          
          \`\`\`bash
          # Download and install (Linux/macOS)
          curl -L https://github.com/tbowman01/PhotonDrift/releases/download/v$VERSION/adrscan-linux-amd64 -o adrscan
          chmod +x adrscan
          
          # Or use with npx
          npx photondrift-cli@latest
          \`\`\`
          
          ## Features
          
          - üèóÔ∏è **Architecture Decision Records (ADR)** management
          - üîç **ML-enhanced drift detection** with 5 algorithms
          - üåê **WebAssembly support** for browser integration
          - üîß **Plugin system** for extensibility
          - üìä **Real-time monitoring** and analysis
          
          ---
          
          **Full Changelog**: [View changes](https://github.com/tbowman01/PhotonDrift/compare/v0.2.0-alpha.20250721...v$VERSION)
          
          > This is $([[ "$VERSION_TYPE" == "alpha" ]] && echo "an alpha" || echo "a release candidate") build from the \`$BRANCH_NAME\` branch.
          > $([[ "$VERSION_TYPE" == "alpha" ]] && echo "Alpha releases are experimental and may contain bugs." || echo "RC releases are stable and ready for production testing.")
          EOF
          
          echo "Generated release notes:"
          cat release-notes.md
      
      - name: Create GitHub release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.semantic-versioning.outputs.version_tag }}
          name: PhotonDrift ${{ needs.semantic-versioning.outputs.new_version }}
          body_path: release-notes.md
          files: release-assets/*
          prerelease: ${{ needs.semantic-versioning.outputs.is_prerelease }}
          draft: false
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Update latest release pointer
        if: needs.semantic-versioning.outputs.version_type == 'rc'
        run: |
          echo "Updating 'latest' release pointer for RC build"
          # RC builds become the latest release
          gh release edit ${{ needs.semantic-versioning.outputs.version_tag }} --latest
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  notification:
    name: Deployment Notification
    runs-on: ubuntu-latest
    needs: [semantic-versioning, create-release]
    if: always()
    
    steps:
      - name: Notify success
        if: needs.create-release.result == 'success'
        run: |
          echo "üéâ PhotonDrift ${{ needs.semantic-versioning.outputs.new_version }} released successfully!"
          echo "üì¶ Release: https://github.com/tbowman01/PhotonDrift/releases/tag/${{ needs.semantic-versioning.outputs.version_tag }}"
          echo "üåü Type: ${{ needs.semantic-versioning.outputs.version_type }}"
      
      - name: Notify failure
        if: needs.create-release.result == 'failure'
        run: |
          echo "‚ùå Release creation failed for version ${{ needs.semantic-versioning.outputs.new_version }}"
          echo "üîç Check the build logs for details"
          exit 1